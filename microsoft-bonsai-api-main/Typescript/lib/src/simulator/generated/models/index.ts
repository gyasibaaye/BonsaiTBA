/*
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */

import { ServiceClientOptions } from "@azure/ms-rest-js";
import * as msRest from "@azure/ms-rest-js";

/**
 * This structure describes the "target" of the simulator;
 * i.e., what trainable construct(s) it exists to service.
 */
export interface PurposeTarget {
  workspaceName?: string;
  /**
   * This is the brain _short_ name!
   */
  brainName?: string;
  brainVersion?: number;
  conceptName?: string;
}

/**
 * The purpose for existing, from the standpoint of a simulator instance or
 * brain version.
 */
export interface Purpose {
  /**
   * Possible values include: 'Inactive', 'Debug', 'Train', 'Assess'
   */
  action?: PurposeTypesAction;
  target?: PurposeTarget;
}

/**
 * This structure is passed (as a string) to a simulator running
 * when launched by the Socrates backend.
 */
export interface SimulatorContext {
  /**
   * Possible values include: 'Unspecified', 'Hosted', 'Testing'
   */
  deploymentMode?: SimulatorContextTypesDeploymentMode;
  /**
   * Where is this simulator deployed
   */
  deploymentDetails?: string;
  /**
   * A simulator id generated by the client
   */
  simulatorClientId?: string;
  /**
   * The id of the collection
   */
  collection?: string;
  /**
   * The id of the package
   */
  packageProperty?: string;
  purpose?: Purpose;
}

/**
 * A summary of a SimulatorSession, returned from ListSessions
 */
export interface SimulatorSessionSummary {
  sessionId?: string;
  /**
   * Possible values include: 'Deregistered', 'Attachable', 'Attached', 'Detaching', 'Rejected'
   */
  sessionStatus?: SimulatorSessionTypesStatus;
  /**
   * From the registration's SimulatorInterface
   */
  simulatorName?: string;
  simulatorContext?: SimulatorContext;
}

/**
 * An interface representing ProblemDetails.
 */
export interface ProblemDetails {
  type?: string;
  title?: string;
  status?: number;
  detail?: string;
  instance?: string;
  /**
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly extensions?: { [propertyName: string]: any };
}

/**
 * It contains all the registration/creation time properties of a simulator session.
 */
export interface SimulatorInterface {
  /**
   * Name of the simulator session.
   */
  name: string;
  /**
   * This is the max time in seconds, within which simulator need to send advance request, else it
   * will be timed out and unregistered from Bonsai platform.
   * Set it to (SimulatorComputeTime + RTT network latency + few seconds)
   * Default is 60s
   */
  timeout?: number;
  /**
   * Additional Capabilities for the session.
   */
  capabilities?: any;
  /**
   * Opaque string to the sim authors. It's used to connect simulator sessions to right brain.false
   * For hosted sims, we automatically take care of setting the right environment variable for
   * this.
   * For Local sims, set it to empty string, and use Bonsai CLI's, `bonsai connect` command.
   */
  simulatorContext?: string;
  /**
   * Schema descriptions of the simulator. Contains State, Action and Config schemas.
   */
  description?: any;
}

/**
 * SimulatorSession progress milestone.
 */
export interface SimulatorSessionMilestone {
  /**
   * First time, this session made the specified progress.
   */
  firstTime?: Date;
}

/**
 * SimulatorSession progress:
 * Has the simulator ever attached to a Scholar;
 * Has the simulator ever iterated (i.e., sent a state and received an action);
 * Has the simulator ever completed an episode (i.e., received an EpisodeFinish message).
 */
export interface SimulatorSessionProgress {
  attached?: SimulatorSessionMilestone;
  iterated?: SimulatorSessionMilestone;
  finishedEpisode?: SimulatorSessionMilestone;
}

/**
 * SimulatorSession model, having details of one active simulator session.
 * When a simulator registers, it creates and starts active simulator session.
 * When that simulator deregisters itself, it ends and removes its simulator session.
 * If the Bonsai platform deregisters a simulator due to that simulator's "misbehavior,"
 * that also ends and removes that simulator's session.
 */
export interface SimulatorSessionResponse {
  /**
   * Unique sessionId for this simulator session.
   */
  sessionId: string;
  /**
   * Possible values include: 'Deregistered', 'Attachable', 'Attached', 'Detaching', 'Rejected'
   */
  sessionStatus?: SimulatorSessionTypesStatus;
  sessionProgress?: SimulatorSessionProgress;
  interfaceProperty?: SimulatorInterface;
  simulatorContext?: SimulatorContext;
  /**
   * Time when this session was registered with Bonsai platform.
   */
  registrationTime: Date;
  /**
   * A recent time that this simulator communicated with the Bonsai platform.
   * This value is updated at a regular interval, so it may not be the most recent communication
   * time.
   */
  lastSeenTime: Date;
  /**
   * A recent time that this simulator received an EpisodeStep from the Scholar.
   * This value is updated at a regular interval, so it may not be the most recent communication
   * time.
   */
  lastIteratedTime: Date;
  /**
   * Current IterationRate, 1 state-action loop is roughly maps to 1 iteration.
   */
  iterationRate?: number;
  /**
   * Additional Details for this session provided by Bonsai platform.
   */
  details?: string;
}

/**
 * EpisodeStart event. It's sent when a new episode need to be started.
 */
export interface EpisodeStart {
  /**
   * Initial configuration of simulation for starting an episode.
   */
  config?: any;
}

/**
 * EpisodeStep event for stepping inthe simulation. this is sent when there is an ongoing active
 * episode.
 */
export interface EpisodeStep {
  /**
   * action decided by RL agent.null use this action to advance from current state of simulator.
   */
  action?: any;
}

/**
 * EpisodeFinish event signalling current episode is finished.
 */
export interface EpisodeFinish {
  /**
   * Possible values include: 'Invalid', 'Unspecified', 'LessonChanged', 'Terminal', 'Interrupted'
   */
  reason?: EpisodeFinishReason;
}

/**
 * Idle Event.null It means, that no RL action was yet available for this session.
 */
export interface Idle {
  /**
   * callback time in seconds. this mean,s you should wait for this much time before sending a new
   * advance request.
   */
  callbackTime?: number;
}

/**
 * Event asking to unregister/delete simulatorSession.
 * You can create a new session, if you want to continue training with this simulator.
 */
export interface Unregister {
  /**
   * Possible values include: 'Unspecified', 'Finished', 'Error', 'NotFound'
   */
  reason?: UnregisterReason;
  /**
   * Detail message for unregister event.
   */
  details?: string;
}

/**
 * RL action returned by bonsai platform when it got new state from simulator session.
 */
export interface Event {
  /**
   * Possible values include: 'Unspecified', 'EpisodeStart', 'EpisodeStep', 'EpisodeFinish',
   * 'Idle', 'Unregister'
   */
  type: EventType;
  /**
   * unique session id.
   */
  sessionId: string;
  /**
   * Always startes with 1, and Bonsai platform increment it at each Step event in advance
   * operation.static
   * Always just return the sequenceId returned by previous advance operation response.
   */
  sequenceId: number;
  episodeStart?: EpisodeStart;
  episodeStep?: EpisodeStep;
  episodeFinish?: EpisodeFinish;
  idle?: Idle;
  unregister?: Unregister;
}

/**
 * It contains simulator state information needed by bonsai platform in response of an action.
 */
export interface SimulatorState {
  /**
   * Always startes with 1, and Bonsai platform increment it at each Step event in advance
   * operation.static
   * Always just return the sequenceId returned by previous advance operation response.
   */
  sequenceId: number;
  /**
   * State of your simulator model.
   */
  state?: any;
  /**
   * Optional halt parameter to indicate, simulator wants to halt.
   * Implicitly false when not present.
   */
  halted?: boolean;
  /**
   * No error if not defined or empty
   */
  error?: string;
}

/**
 * An interface representing SimulatorAPIOptions.
 */
export interface SimulatorAPIOptions extends ServiceClientOptions {
  baseUri?: string;
}

/**
 * Optional Parameters.
 */
export interface SessionListOptionalParams extends msRest.RequestOptionsBase {
  /**
   * A specifier to filter on deployment mode
   */
  deploymentMode?: string;
  /**
   * A specifier to filter on session status
   */
  sessionStatus?: string;
  /**
   * If present, only sessions in this collection
   */
  collection?: string;
  /**
   * If present, only sessions in this package
   */
  packageParameter?: string;
}

/**
 * Defines values for SimulatorSessionTypesStatus.
 * Possible values include: 'Deregistered', 'Attachable', 'Attached', 'Detaching', 'Rejected'
 * @readonly
 * @enum {string}
 */
export type SimulatorSessionTypesStatus = 'Deregistered' | 'Attachable' | 'Attached' | 'Detaching' | 'Rejected';

/**
 * Defines values for SimulatorContextTypesDeploymentMode.
 * Possible values include: 'Unspecified', 'Hosted', 'Testing'
 * @readonly
 * @enum {string}
 */
export type SimulatorContextTypesDeploymentMode = 'Unspecified' | 'Hosted' | 'Testing';

/**
 * Defines values for PurposeTypesAction.
 * Possible values include: 'Inactive', 'Debug', 'Train', 'Assess'
 * @readonly
 * @enum {string}
 */
export type PurposeTypesAction = 'Inactive' | 'Debug' | 'Train' | 'Assess';

/**
 * Defines values for EventType.
 * Possible values include: 'Unspecified', 'EpisodeStart', 'EpisodeStep', 'EpisodeFinish', 'Idle',
 * 'Unregister'
 * @readonly
 * @enum {string}
 */
export type EventType = 'Unspecified' | 'EpisodeStart' | 'EpisodeStep' | 'EpisodeFinish' | 'Idle' | 'Unregister';

/**
 * Defines values for EpisodeFinishReason.
 * Possible values include: 'Invalid', 'Unspecified', 'LessonChanged', 'Terminal', 'Interrupted'
 * @readonly
 * @enum {string}
 */
export type EpisodeFinishReason = 'Invalid' | 'Unspecified' | 'LessonChanged' | 'Terminal' | 'Interrupted';

/**
 * Defines values for UnregisterReason.
 * Possible values include: 'Unspecified', 'Finished', 'Error', 'NotFound'
 * @readonly
 * @enum {string}
 */
export type UnregisterReason = 'Unspecified' | 'Finished' | 'Error' | 'NotFound';

/**
 * Contains response data for the list operation.
 */
export type SessionListResponse = Array<SimulatorSessionSummary> & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: SimulatorSessionSummary[];
    };
};

/**
 * Contains response data for the create operation.
 */
export type SessionCreateResponse = SimulatorSessionResponse & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: SimulatorSessionResponse;
    };
};

/**
 * Contains response data for the get operation.
 */
export type SessionGetResponse = SimulatorSessionResponse & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: SimulatorSessionResponse;
    };
};

/**
 * Contains response data for the getMostRecentAction operation.
 */
export type SessionGetMostRecentActionResponse = Event & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: Event;
    };
};

/**
 * Contains response data for the advance operation.
 */
export type SessionAdvanceResponse = Event & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: Event;
    };
};
